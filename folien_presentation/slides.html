<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Testing im Frontend</title>

    <link rel="stylesheet" href="node_modules/reveal.js/dist/reveal.css">
    <link rel="stylesheet" href="node_modules/reveal.js/dist/theme/white.css" id="theme">
    <link rel="stylesheet" href="node_modules/highlight.js/styles/atom-one-dark.css">

    <script src="node_modules/reveal.js/plugin/markdown/markdown.js"></script>

    <style media="screen">
        .slides section.has-dark-background, k
        .slides section.has-dark-background h2 {
            color: #fff;
        }

        .slides section.has-light-background,
        .slides section.has-light-background h2 {
            color: #222;
        }

        .reveal code {
            tab-size: 0;
            -moz-tab-size: 1;
            -o-tab-size: 1;
            -webkit-tab-size: 1;
        }

        h1, h2, h3, h4, h5, h6 {
            color: #006ec7 !important;
        }


        .highlight {
            color: #006ec7;
        }

        .small-text {
            font-size: 0.8em;
        }

        .custom-height-slide pre code {
            white-space: pre-wrap;
            max-height: 500px;
            max-height: 1500px;
            overflow-y: visible;
        }

        .adesso-logo {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 3em;
            height: auto;
        }
    </style>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section>
            <h1>Testing im Frontend</h1>
        </section>
        <section>
            <section>
                <h2>Agenda</h2>
                <ul>
                    <li>Vorstellungsrunde</li>
                    <li>Grundlagen Testing</li>
                    <li>Testen im Frontend</li>
                    <li>Cypress Intro</li>
                    <li>Cypress Übungen</li>
                </ul>
            </section>
            <section>
                <h2>Pausen</h2>
                <ul>
                    <li>09:00 - 10.30 Uhr</li>
                    <li>10:45 - 12:30 Uhr</li>
                    <li>13:00 - 14:30 Uhr</li>
                    <li>14:45 - 17:00 Uhr</li>
                </ul>
            </section>
            <section>
                <h2>Vorstellungsrunde</h2>
                <ul>
                    <li>Name</li>
                    <li>Rolle im Projekt</li>
                    <li>Erwartungen für die Schulung</li>
                    <li>...</li>
                </ul>
            </section>
            <section data-background-image="./images/menti.png" data-background-size="80%"></section>
        </section>
        <section>
            <section>
                <h1>Grundlagen Testing</h1>
            </section>
            <section>
                <h2>Warum testen wir überhaupt?</h2>
            </section>
            <section>
                <div class="r-vstack">
                    <img class="r-stretch" src="images/paypal_bug.png" width="1000px"/>
                </div>
                <aside class="notes">
                    https://osxdaily.com/2011/03/13/iphone-daylight-savings-time-bug-fall-back-instead-of-spring-forward/
                </aside>
            </section>
            <section>
                <h2>5 Gründe, warum Tests unsere Nerven (und Projekte) retten</h2>
            </section>
            <section>
                <h2>1. Bugs möglichst früh finden</h2>
                <img class="slider-stretch" src="images/bugs-finden.png" alt="Bugs finden">
                <div class="fragment">Je früher ein Fehler gefunden wird, desto <span class="highlight">einfacher</span>,
                    <span class="highlight">schneller</span> und damit auch
                    <span class="highlight">günstiger</span> ist er zu beheben.
                </div>
            </section>
            <section>
                <h2>2. Langfristige Absicherung durch Regressionstests</h2>
                <p class="fragment">Neue Features können hinzugefügt werden, ohne bestehende Funktionalitäten zu
                    gefährden.</p>
            </section>
            <section>
                <h2>Was ist besser testbar?</h2>
                <div style="display: flex; align-items: center; justify-content: center;">
                    <img class="fragment" src="images/network-switch-unorganized.png" alt="Network Switch 1"
                         height="400px"
                         style="margin-right: 20px;">
                    <h3 class="fragment">vs.</h3>
                    <img class="fragment" src="images/network-switch-organized.png" alt="Network Switch 2"
                         style="margin-left: 20px;">
                </div>
            </section>
            <section>
                <h2>3. Wartbarkeit erhöhen</h2>
                <p class="fragment">Tests führen oft dazu, dass Code modular und verständlich geschrieben wird.</p>
            </section>
            <section>
                <h2>4. Grenzfälle abtesten</h2>
                <p class="fragment">Weil es immer jemanden gibt, der Dinge anders benutzt, als sie gedacht sind.</p>
            </section>
            <section>
                <h2>Was sind Grenzfälle?</h2>
                <ul>
                    <li class="fragment"><span class="highlight">Ungültige Eingaben</span>: Buchstaben statt Zahlen</li>
                    <li class="fragment"><span class="highlight">Ungewöhnliche Nutzung</span>: z.B. extrem hohe oder
                        niedrige Werte
                    </li>
                    <li class="fragment"><span class="highlight">Ressourcenprobleme</span>: Ressource (z.B.
                        Internetverbindung) ist nicht verfügbar.
                    </li>
                    <li class="fragment"><span class="highlight">Leistungsgrenzen</span>: Sehr hohen Anzahl von Anfragen
                        oder Daten
                    </li>
                    <li class="fragment"><span class="highlight">Sicherheitslücken</span></li>
                    <li class="fragment"><span class="highlight">Kompatibilitätsprobleme</span>: Nutzung des Systems auf
                        nicht unterstützten Geräten oder Browsern.
                    </li>
                </ul>
            </section>
            <section>
                <h2>Beispiel Grenzfälle</h2>
                <pre><code class="javascript" data-line-numbers="1-9|11|12|13|14">const divide = (a, b) => {
    if (typeof a !== 'number' || typeof b !== 'number') {
        return 'Eingaben müssen Zahlen sein';
    }
    if (b === 0) {
        return 'Division durch Null ist nicht erlaubt';
    }
    return a / b;
};

console.log(divide(10, 0)); // Grenzfall: Division durch Null
console.log(divide(0, 10)); // Grenzfall: 0
console.log(divide(-10, 2)); // Grenzfall: negative Zahl
console.log(divide(10, 'a')); // Grenzfall: String als Eingabe
    </code></pre>
            </section>
            <section>
                <h2>5. Dokumentation</h2>
                <p class="fragment">Weil niemand Lust hat, nach einem Jahr wieder herauszufinden, was ‘doSomething()’
                    eigentlich tut.</p>
            </section>
        </section>
        <section>
            <section><h1>Testarten</h1></section>
            <section>
                <h2>Automatisiertes Testen</h2>
                <p>vs.</p>
                <h2>Manuelles Testen</h2>
            </section>
            <section>
                <h2>Manuelles Testen</h2>
                <p class="fragment">... ist der Prozess, bei dem <b class="highlight">Tester</b> Software <b
                        class="highlight">manuell</b> ausführen, um Fehler zu finden. Es
                    erfordert keine Automatisierungstools.</p>
                <ul>
                    <li class="fragment">Zeitaufwändig</li>
                    <li class="fragment">Monoton</li>
                    <li class="fragment">Fehleranfällig</li>
                    <li class="fragment">Subjektiv</li>
                    <li class="fragment">Teuer</li>
                </ul>
            </section>
            <section>
                <h2>Automatisiertes Testen</h2>
                <p class="fragment">... ist der Prozess, bei dem Tests mithilfe von
                    <b class="highlight">Software-Tools automatisch</b> ausgeführt werden, um die Funktionalität und
                    Qualität der Software sicherzustellen.</p>
                <ul>
                    <li class="fragment">Wiederholbar</li>
                    <li class="fragment">Skalierbar</li>
                    <li class="fragment">Zeitsparend</li>
                </ul>
            </section>
            <section>
                <h2>Testpyramide</h2>
                <img class="r-stretch" src="images/testingpyramide.png"/>
            </section>
            <section>
                <h2>Was ist Unit Testing?</h2>
                <p class="fragment">Testen von einzelnen Units</p>
                <p class="fragment">Automatisiert</p>
                <p class="fragment">Isoliert</p>
            </section>
            <section>
                <h2>Was ist eine Unit?</h2>
                <p class="fragment">Der kleinste Baustein einer Applikation</p>
                <p class="fragment">z.B. Funktionen oder Klassen</p>
            </section>
            <section>
                <h2>Grundannahme Unit Testing:</h2>
                <p>Wenn <b class="highlight">alle Units</b> korrekt funktionieren, dann funktioniert auch die <b
                        class="highlight">gesamte Applikation</b> korrekt.</p>
            </section>
            <section>
                <h2>Vorteile von Unit Testing</h2>
                <ul>
                    <li class="fragment"><span class="highlight">Frühes Erkennen von Fehlern:</span> Fehler können
                        frühzeitig im Entwicklungsprozess entdeckt und behoben werden
                    </li>
                    <li class="fragment"><span class="highlight">Modularität:</span> Unit Tests fördern die Entwicklung
                        modularen und wartbaren Codes
                    </li>
                    <li class="fragment"><span class="highlight">Schnelle Rückmeldung:</span> Entwickler erhalten
                        schnell Rückmeldung über die Korrektheit ihres Codes
                    </li>
                </ul>
            </section>
            <section>
                <h2>Integration Tests</h2>
                <video data-autoplay height="250px" src="videos/9zf0asd0c3n51.mp4"></video>
                <p class="fragment">Funktionieren die einzelnen Komponenten auch im Zusammenspiel miteinander?</p>
            </section>
            <section>
                <h2>End-To-End Tests</h2>
                <ul>
                    <li class="fragment">Simulieren das echte Nutzererlebnis</li>
                    <li class="fragment">Testen ganzheitliche Geschäftsabläufe</li>
                    <li class="fragment"><b class="highlight">Ziel:</b> Aufdeckung von Fehlern aus Benutzersicht</li>
                    <li class="fragment"><b class="highlight">Nachteil:</b> E2E-Tests sind teuer und haben lange
                        Ausführungszeiten, müssen sich also lohnen
                    </li>
                </ul>
            </section>
            <section>
                <h2>Keine harten Grenzen</h2>
                <img class="r-stretch" src="images/keine-harten-grenzen.png"/>
            </section>
        </section>
        <section>
            <section>
                <h1>Ist Testen im Frontend sinnvoll?</h1>
                <p class="fragment">⚠️ Achtung Spoiler</p>
                <p class="fragment"><b class="highlight">Definitiv 😉</b></p>
            </section>
            <section>
                <h2>Wie kann ich Unit-Tests im Frontend sinnvoll nutzen?</h2>
                <ul>
                    <li class="fragment">Testen von isolierten Einheiten wie Pipes, Direktiven, Services und Methoden in
                        Komponenten
                    </li>
                    <li class="fragment">Abhängigkeiten werden nicht betrachten bzw gemockt</li>
                    <li class="fragment">Es können sehr einfach Grenzfälle getestet werden</li>
                    <li class="fragment"><b class="highlight">Tools:</b> z.B. mit <span class="highlight">Jest</span>
                        oder <span class="highlight">Karma</span> mit <span
                                class="highlight">Angular Testing Library</span> oder <span
                                class="highlight">Spectator</span>
                    </li>
                </ul>
            </section>

            <section>
                <h3>Beispiel Unit Testing im Frontend</h3>
                <p>Wir prüfen, ob eine Pipe die erwartete Transformation durchführt</p>
                <pre><code class="typescript" data-line-numbers="2-5,14|6,13|7-9|10-12">// Angular Pipe
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({name: 'decimalFormat'})
export class DecimalFormatPipe implements PipeTransform {
    transform(value: number | undefined): string {
        if (value === undefined) {
            return 'N/A';
        }
        return value.toLocaleString('de-DE', {
                    minimumFractionDigits: 2,
                    maximumFractionDigits: 2});
    }
}</code></pre>
            </section>

            <section class="custom-height-slide">
                <h3>Beispiel Unit Testing im Frontend</h3>
                <pre><code class="typescript" data-line-numbers="2|4,18|5|7-9|11-13|15-17">// Test mit Jest
import { DecimalFormatPipe } from './decimal-format.pipe';

describe('DecimalFormatPipe', () => {
    const pipe = new DecimalFormatPipe();

    it('should format number to German format', () => {
        expect(pipe.transform(17.93)).toBe('17,93');
    });

    it('should return "N/A" for undefined', () => {
        expect(pipe.transform(undefined)).toBe('N/A');
    });

    it('should format number without decimal places', () => {
        expect(pipe.transform(17)).toBe('17,00');
    });
});</code></pre>
            </section>
            <section>
                <h3>Wie schreibe ich Integration Tests im Frontend?</h3>
                <ul>
                    <li class="fragment"><span class="highlight">Snapshot-Tests</span>: Erfassen und Vergleichen des
                        HTML-Outputs, um
                        unerwartete Änderungen zu erkennen.
                    </li>
                    <li class="fragment"><span class="highlight">DOM-Tests</span>: Überprüfen, ob die DOM-Struktur und
                        Inhalte korrekt
                        gerendert
                        werden.
                    </li>
                    <li class="fragment"><span class="highlight">Component-Tests</span>: Testen von Komponenten in
                        Isolation, aber mit
                        Template-Rendering, um sicherzustellen, dass sie wie erwartet funktionieren.
                    </li>
                </ul>
            </section>

            <section>
                <h2>Snapshot Testing</h2>
                <ul>
                    <li class="fragment"><b>Snapshot</b> = UI Rendering Ergebnis</li>
                    <li class="fragment"><b>Referenzwert:</b> Sieht die UI nach Veränderungen noch so aus wie
                        vorher?
                    </li>
                    <li class="fragment"><b>Ziel:</b> Absichern visueller Konsistenz (z. B. Positionierung von
                        Elementen, Farben, Typografie)
                    </li>
                </ul>
            </section>
            <section>
                <h3>Beispiel für einen Snapshot-Test mit Jest:</h3>
                <pre><code class="typescript" data-line-numbers="1|2|4,7|5|6">import { render } from '@testing-library/angular';
import { MyComponent } from './my-component.component';

test('MyComponent Snapshot', async () => {
  const { container } = await render(MyComponent);
  expect(container).toMatchSnapshot();
});
    </code></pre>
            </section>
            <section>
                <h3>Beispiel für einen Snapshot-Test mit Jest:</h3>
                <pre><code class="typescript fragment" data-line-numbers>// MyComponent
import { Component } from '@angular/core';

@Component({
  selector: 'app-my-component',
  template: `<div>Hello World</div>`
})
export class MyComponent {}
    </code></pre>
                <pre><code class="html fragment" data-line-numbers>exports[`MyComponent Snapshot 1`] = `
<div>
  <div>Hello World</div>
</div>
`;
    </code></pre>
            </section>
            <section>
                <h2>Snapshot Testing - Vorteile</h2>
                <ul>
                    <li class="fragment">Einfache Implementierung</li>
                    <li class="fragment">Schnelle Überprüfung von UI-Änderungen</li>
                    <li class="fragment">Automatische Erkennung von unbeabsichtigten Änderungen</li>
                </ul>
            </section>
            <section>
                <h2>Snapshot Testing - Nachteile</h2>
                <ul>
                    <li class="fragment">Kann zu False Positives/False Negatives führen</li>
                    <li class="fragment">Snapshots können groß und unübersichtlich werden</li>
                    <li class="fragment">Erfordert regelmäßige Aktualisierung der Snapshots</li>
                    <li class="fragment">Wird bei Major-Version-Updates oft wirkungslos</li>
                </ul>
            </section>

            <section>
                <h2>Domain Object Model (DOM) Testing</h2>
                <p><b class="highlight">Definition:</b> DOM-Tests sind Tests, die sicherstellen, dass JavaScript-Code
                    korrekt mit dem Document Object Model (DOM) einer Webseite interagiert und dabei das Verhalten des
                    Browsers simulieren.</p>
            </section>

            <section>
                <h3>Wofür schreibe ich DOM Tests?</h3>
                <ul>
                    <li class="fragment">Wenn du sicherstellen möchtest, dass Events wie Klicks, Eingaben oder
                        Änderungen korrekt behandelt werden.
                    </li>
                    <li class="fragment">Bei der Überprüfung von Formvalidierungen oder Interaktionen innerhalb von
                        Formularen.
                    </li>
                    <li class="fragment">Um zu testen, ob dynamische Inhalte, die durch JavaScript eingefügt werden,
                        korrekt angezeigt werden.
                    </li>
                    <li class="fragment">Wenn du sicherstellen möchtest, dass UI-Komponenten (wie Modals, Dropdowns
                        oder Tooltips) korrekt funktionieren und anzeigen.
                    </li>
                </ul>
            </section>
            <section class="custom-height-slide">
                <h2>DOM-Test Beispiel</h2>
                <pre><code class="typescript" data-line-numbers="2|4-5,7-8,12|6|9-11">// Button Component
import { Component } from '@angular/core';

@Component({
  selector: 'app-button',
  template: `<button (click)="handleClick()">
                        Klick mich!</button>`,
})
export class ButtonComponent {
  handleClick() {
    console.log('Button wurde geklickt!');
  }
}</code></pre>
            </section>
            <section class="custom-height-slide">
                <h2>DOM-Test Beispiel</h2>
                <pre><code class="typescript" data-line-numbers="1-2|5-6,17|7|8|10-11|13|15-16">import { render, fireEvent }
                    from '@testing-library/angular';
import { ButtonComponent } from './button.component';

test('ButtonComponent sollte einen Konsolenausdruck
                    bei Klick auslösen', async () => {
  const { getByText } = await render(ButtonComponent);
  const button = getByText('Klick mich!');

  // Mock für console.log
  const consoleSpy = jest.spyOn(console, 'log');

  fireEvent.click(button);

  expect(consoleSpy)
    .toHaveBeenCalledWith('Button wurde geklickt!');
});
    </code></pre>
            </section>
            <section>
                <h2>DOM Testing - Vorteile</h2>
                <ul>
                    <li class="fragment">Detaillierte Überprüfung der DOM-Struktur</li>
                    <li class="fragment">Simuliert Benutzerinteraktionen</li>
                    <li class="fragment">Erkennt Fehler in der Benutzeroberfläche</li>
                </ul>
            </section>
            <section>
                <h2>DOM Testing - Nachteile</h2>
                <ul>
                    <li class="fragment">Komplexere Implementierung</li>
                    <li class="fragment">Kann langsamer sein als Snapshot-Tests</li>
                    <li class="fragment">Erfordert mehr Wartung</li>
                    <li class="fragment">Bilder nicht die Realität ab</li>
                </ul>
            </section>

            <section>
                <h2>Component Testing z.B. mit Cypress</h2>
                <p class="fragment">Component Testing ermöglicht das Testen von isolierten UI-Komponenten
                    (Black-Box-Testing)</p>
            </section>
            <section>
                <h2>Vorteile von Component Tests</h2>
                <ul>
                    <li class="fragment">Näher an der Realität als Snapshot oder DOM Tests, aber einfachereres Setup als
                        E2E Tests
                    </li>
                    <li class="fragment">Einfaches Debugging</li>
                </ul>
            </section>
            <section>
                <h2>Nachteile von Component Tests</h2>
                <ul>
                    <li class="fragment"><span class="highlight">Isolierung:</span> Interaktionen mit anderen
                        Komponenten oder dem Gesamtsystem können übersehen werden.
                    </li>
                    <li class="fragment"><span class="highlight">Komplexität:</span> Das Setup kann komplex sein,
                        insbesondere bei vielen gemockten Abhängigkeiten.
                    </li>
                    <li class="fragment"><span class="highlight">Performance:</span> Können langsamer
                        sein als Unit-Tests, da sie das Rendering und die Interaktion mit dem DOM beinhalten.
                    </li>
                </ul>
            </section>
            <section>
                <h3>Beispiel für einen Component Test</h3>
                <pre><code class="typescript" data-line-numbers="1|2|4,9|5,8|6|7">import { mount } from 'cypress/angular';
import { MyComponent } from './my-component.component';

describe('MyComponent', () => {
  it('should render correctly', () => {
    mount(MyComponent);
    cy.get('h1').should('contain', 'Hello World');
  });
});
    </code></pre>
            </section>

            <section>
                <h2>End-To-End Tests</h2>
                <p>Simulieren das echte Nutzererlebnis.</p>
                <p>Testen ganzheitliche Geschäftsabläufe.</p>
                <li class="fragment"><b class="highlight">Tools:</b> z.B. mit <span class="highlight">Cypress</span>
                    oder <span class="highlight">Playwright</span></li>
                <p><b>Ziel:</b> Aufdeckung von Fehlern aus Benutzersicht, möglichst nah an der Realität</p>
                <p><b>Nachteil:</b> E2E-Tests sind teuer und haben lange Ausführungszeiten, müssen sich also lohnen.
                </p>
            </section>

            <section>
                <p>Zurück zu der Frage:</p>
                <h1 class="fragment">Ist Testen im Frontend sinnvoll?</h1>
            </section>
            <section>
                <h2>Kosten-Nutzen-Analyse des Testens im Frontend</h2>
                <p class="fragment"><span class="highlight">Arbeitsgeschwindigkeit:</span> Tests erhöhen die Effizienz
                    und Geschwindigkeit der Entwicklung.</p>
                <p class="fragment"><span class="highlight">Vertrauen in die Software:</span> Tests schaffen Vertrauen
                    in die Stabilität und Zuverlässigkeit der Software bei allen Stakeholdern.</p>
            </section>
            <section>
                <h2>Aber:</h2>
                <p class="fragment">Frontend-Bugs sind oft nicht so gravierend und eher seltener als Bugs im
                    Backend.</p>
            </section>
            <section>
                <h2>Wie viel sollte ich also in FE-Tests mindestens investieren?</h2>
                <ul>
                    <li class="fragment"><span class="highlight">Smoke-Tests:</span> Tests, die sicherstellen, dass die
                        Software überhaupt läuft.
                    </li>
                    <li class="fragment"><span class="highlight">Kritische Prozesse:</span>
                        <ul>
                            <li class="fragment">Benutzerinteraktion (bspw. Speichern von Daten aus Forms)</li>
                            <li class="fragment">Korrekte Darstellung wichtiger UI-Elemente</li>
                            <li class="fragment">Integration mit dem Backend (API)</li>
                            <li class="fragment">Routing & Navigation</li>
                            <li class="fragment">Fehlerfälle (Validierung, Fehlermeldungen, Nutzer macht Unfug)</li>
                        </ul>
                    </li>
                </ul>
            </section>
        </section>
        <section>
            <section>
                <h2>Instanziierungstests: Ja oder Nein?</h2>
                <p class="fragment">Instanziierungstests prüfen, ob eine Komponente oder ein Service korrekt erstellt
                    werden kann.</p>
                <p class="fragment">Sie sind nützlich, um sicherzustellen, dass alle Abhängigkeiten korrekt aufgelöst
                    werden.</p>
            </section>
            <section>
                <h2>Beispiel Instanziierungstest</h2>
                <pre class="fragment"><code class="typescript" data-line-numbers="4-10,15|12-14">import { TestBed } from '@angular/core/testing';
import { MyService } from './my-service.service';

describe('MyService', () => {
  let service: MyService;

  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(MyService);
  });

  it('should be created', () => {
    expect(service).toBeTruthy();
  });
});</code></pre>
            </section>
            <section>
                <h2>Instanziierungstests - Pro</h2>
                <ul>
                    <li class="fragment">Hilft, bei der Initialisierung von Angular-Anwendungen sicherzustellen, dass
                        keine grundlegenden Fehler im Setup existieren (Smoke-Test).
                    </li>
                    <li class="fragment">Besonders in komplexen Angular-Anwendungen kann es sinnvoll sein, zu prüfen, ob
                        alle notwendigen Abhängigkeiten korrekt aufgelöst und injiziert werden.
                    </li>
                    <li class="fragment">Test-Setup existiert dann schon. Kleinere Hürde für andere Entwickler, Tests zu
                        ergänzen.
                    </li>
                </ul>
            </section>
            <section>
                <h2>Instanziierungstests - Kontra</h2>
                <ul>
                    <li class="fragment">Unnötig, wenn du davon ausgehst, dass der Kompilierprozess und Angular's
                        Dependency Injection gut funktioniert
                    </li>
                    <li class="fragment">Kann Zeit verschwenden</li>
                    <li class="fragment">Müssen auf Dauer evtl. gewartet werden (bspw. bei Umstieg auf ein anderes
                        Testing Tool), ohne großen Mehrwert zu bieten
                    </li>
                </ul>
            </section>
            <section>
                <h2>Instanziierungstests: Ja oder Nein?</h2>
                <p class="fragment">was denkt ihr darüber?</p>
            </section>
        </section>
        <section>
            <section>
                <h2>Quality Gate: Testabdeckung</h2>
                <p class="fragment">Testabdeckung ist ein Maß dafür, wie viel Prozent des Codes durch Tests abgedeckt
                    sind.</p>
            </section>
            <section>
                <h3>Beispiel 1</h3>
                <p class="fragment">Ein Team startet auf "Grüner Wiese" und die Projektleitung legt eine
                    Mindesttestabdeckung des Codes von 80 % durch Unit-Tests fest.</p>

                <h3 class="fragment">Beispiel 2</h3>
                <p class="fragment">Ein neues Team wartet eine alte Software mit 20 % Coverage und soll nun nachträglich
                    die Coverage durch Unit-Tests auf 65 % hochzuziehen.</p>

                <h3 class="fragment">Was denkt ihr darüber - Sinnvoll oder nicht?</h3>
            </section>
            <section>
                <h2>Gefahren der Testabdeckung</h2>
                <ul>
                    <li class="fragment">Falsche Sicherheit - Infrastrukturkritischer Code ist komplex und wird nicht
                        getestet (z.B. DB Verbindung)
                    </li>
                    <li class="fragment">Code wird schlecht getestet, um schnell fertig zu werden</li>
                    <li class="fragment">Unwichtige Stellen werden getestet, nur um nötige Coverage zu erreichen</li>
                </ul>
            </section>
            <section>
                <h2>Was sind sinnvolle Fragen zur Testabdeckung?</h2>
                <ul>
                    <li class="fragment">Wie können wir die Testabdeckung kontinuierlich überwachen und verbessern?</li>
                    <li class="fragment">Welche Metriken verwenden wir, um die Qualität unserer Tests zu bewerten?</li>
                    <li class="fragment">Wie gehen wir mit nicht testbarem Code um, z.B. externen Abhängigkeiten oder
                        Legacy-Code?
                    </li>
                </ul>
            </section>
        </section>
        <section>
            <section>
                <h2>Wie schreibe ich gute Tests?</h2>
            </section>
            <section>
                <h2>Arrange, Act, Assert</h2>
                <p class="fragment">Ein Muster zur Strukturierung von Tests</p>
                <ul>
                    <li class="fragment"><b>Arrange:</b> Bereite die Testdaten und den Zustand vor.</li>
                    <li class="fragment"><b>Act:</b> Führe die zu testende Aktion aus.</li>
                    <li class="fragment"><b>Assert:</b> Überprüfe das Ergebnis.</li>
                </ul>
            </section>
            <section>
    <pre><code class="typescript" data-line-numbers="4-6|8-9|11-12">import { add } from './math';

test('add function should return correct sum', () => {
    // Arrange
    const a = 2;
    const b = 3;

    // Act
    const result = add(a, b);

    // Assert
    expect(result).toBe(5);
});
    </code></pre>
            </section>
            <section>
                <h2>Halte Tests so einfach wie möglich</h2>
                <p class="fragment">Je komplexer ein Test ist, desto schwerer ist er zu warten.</p>
            </section>
            <section>
                <h2>Teste immer nur eine Funktionalität pro Test</h2>
                <p class="fragment">So weißt du immer direkt, was fehlgeschlagen ist.</p>
            </section>
            <section>
                <h2>Halte die Anzahl der Assertions gering</h2>
                <p class="fragment">Versuche die Anzahl von Expect-Statements (Assertions) gering zu halten, außer sie
                    testen tatsächlich
                    die selbe Sache.</p>
            </section>
            <section>
                <h2>Teste nichts, was du nicht ändern kannst.</h2>
                <p class="fragment">Teste keinen "Third-Party-Code" (externe Libraries, Packages, Frameworks, Native
                    Node.js Packages,
                    Browser APIs etc.).</p>
            </section>

        </section>
        <section>
            <section>
                <h2>Stubs, Spies und Mocks</h2>
            </section>
            <section>
                <h2>Stubs</h2>
                <p class="fragment">Gibt bei Aufruf immer denselben statischen Return-Wert zurück. Wenn uns vollkommen
                    egal ist, wie die
                    Entität sich verhält. Hauptsache keine Exception.</p>
            </section>
            <section>
                <h2>Spies</h2>
                <p class="fragment">"Wrapper" um Funktionen oder leeren Ersatz für Funktionen, die uns erlauben zu
                    verfolgen, ob und wie
                    eine Funktion aufgerufen wurde.</p>
            </section>
            <section>
                <h2>Mocks</h2>
                <p class="fragment">Ein Ersatz für eine API, die uns stattdessen ein test-spezifisches Verhalten
                    liefert.</p>
            </section>
        </section>
        <section>
            <section data-background-image="./images/stars.jpg">
                <img class="r-stretch" src="images/Cypress_Logotype_White-Color.png"/>

            </section>
            <section>
                <h2>Keine harten Grenzen</h2>
                <img class="r-stretch" src="images/keine-harten-grenzen.png"/>
            </section>
            <section>
                <h2>Und was macht Cypress?</h2>
                <img class="r-stretch" src="images/keine-harten-grenzen-cypress.png"/>
            </section>
            <section>
                <h1>Developer Experience</h1>
                <h2 class="fragment">Die Cypress Philosophie</h2>
            </section>
            <section>
                <h2>Batteries included - Das Cypress Setup</h2>
                <ul>
                    <li class="fragment">Testing Framework: Mocha</li>
                    <li class="fragment">Assertion Library: Chai</li>
                    <li class="fragment">Launcher/ Test Runner</li>
                    <li class="fragment">Reporter</li>
                    <li class="fragment">Browser: Electron</li>
                    <li class="fragment">Proxy (für Request Stubbing)</li>
                </ul>
            </section>
            <section>
                <h2>Die Cypress Desktop App</h2>
                <ul>
                    <li class="fragment">Vereinfacht das Schreiben der Tests</li>
                    <li class="fragment">Visuell aufbereitetes Feedback</li>
                    <li class="fragment">Timetravel</li>
                    <li class="fragment">Übersichtliches Debugging</li>
                </ul>
            </section>
            <section>
                <h2>Sehr einfaches Mocking/ Stubbing</h2>
                <p class="fragment">Wenn die Realität mal wieder nicht perfekt ist...</p>
            </section>
            <section>
                <h2>Wundervolle Dokumentation</h2>
                <ul>
                    <li class="fragment">... um Cypress zu lernen</li>
                    <li class="fragment">... um die Best Practices zu erfahren</li>
                    <li class="fragment">... um CI aufzusetzen</li>
                    <li class="fragment">...</li>
                </ul>
            </section>
        </section>
        <section>
            <section>
                <h1>Cypress Setup</h1>
            </section>
            <section>
                <pre class="bash"><code data-trim data-noescape data-line-numbers="1|2" class="hljs">
                    $ npm  install  –-save-dev  cypress
                    $ npx  cypress  open
                </code></pre>
            </section>
            <section>
                <h1>Let's see the magic</h1>
            </section>
        </section>
        <section>
            <section>
                <h1>Testaufbau</h1>
            </section>
            <section>
                <pre data-id="code" class="javascript"><code data-line-numbers="1,12|2-4|6,11|7-10" class="hljs"
                >describe('login', () => {
  beforeEach(() => {
    cy.visit('http://localhost:4200/');
  })

  it('should successfully login', () => {
    cy.contains('Bingo');

    cy.get('[data-cy="login-form"]')
        .should('contain', 'Anmeldung');
  })
})
                </code></pre>
                <aside class="notes">$('.my-selector') --> jQuery</aside>
            </section>
            <section>
                <h2>Assertions vs. Commands</h2>
                <p class="fragment"><strong>Commands</strong> sind Aktionen, die auf der Seite ausgeführt werden
                </p>
                <p class="fragment"><strong>Assertions</strong> sind Überprüfungen, die das Verhalten der Seite
                    testen.
                </p>
                <pre data-id="code" class="javascript fragment"><code data-line-numbers class="hljs"
                >cy.get('my-selector')           // Command
    .should('have.length',5);   // Assertion
                </code></pre>
            </section>
            <section>
                <h2>Commands: Query vs. Non-Query</h2>
                <p class="fragment"><strong>Query</strong>: Elemente finden</p>
                <p class="fragment"><strong>Non-Query</strong>: Aktionen ausführen</p>
                <p class="fragment">=> Query Commands geben ein Element zurück, Non-Query Commands nicht.</p>


                <pre data-id="code" class="javascript fragment"><code data-line-numbers class="hljs"
                >cy.get('button')       // Query Command
    .click();         // Non-Query Command
                </code></pre>
            </section>
        </section>
        <section>
            <h1>Übung 1: Login</h1>
            <h2>Zum Repo auf GitHub</h2>
            <img class="r-stretch" src="images/qr-code-repo.png"/>
            <p>https://github.com/hannahebert/cypress-schulung-adesso</p>
        </section>
        <section>
            <h2>Get vs. Find vs. contains </h2>
            <p><strong>cy.get()</strong> - Findet ein Element</p>
            <p><strong>cy.find()</strong> - Findet ein Kind-Element</p>
            <p><strong>cy.contains()</strong> - Findet ein Element anhand des Textes</p>

            <pre data-id="code" class="javascript fragment"><code data-line-numbers class="hljs"
            >cy.contains('Bingo');

cy.get('[data-cy="login-form"]')
    .find('h3')
    .should('contain', 'Anmeldung');
                </code></pre>
        </section>

        <section>
            <h1>Übung 2: Bingo</h1>
        </section>

        <section>
            <section>
                <h2>Custom Cypress Command: Login</h2>
                <pre><code class="typescript" data-line-numbers="1-2,17|3-12|13-14|16"
                >Cypress.Commands.add('login',(username: string,
                    password: string): void => {
  cy.visit('login');
  cy.get('[data-cy="username"]')
    .type('cypress', {log: false});
  cy.get('[data-cy="password"]')
    .type('bingo', {log: false});

  cy.get('[data-cy="submit-button"]')
    .click()
    .should('not.exist');

  cy.url()
    .should('eq', `${Cypress.config().baseUrl}/bingo-board`);

  cy.get('.board-title').should('have.text', 'Bingo');
});
    </code></pre>
            </section>
        </section>

        <section>
            <h1>Übung 3: Custom Command</h1>
        </section>

        <section>
            <section>
                <h2>Chain of Commands - Retry Logic</h2>
            </section>
            <section data-auto-animate>
                <h2>Chain of Commands - Retry Logic</h2>
                <pre data-id="code" class="javascript fragment"><code data-line-numbers class="hljs"
                >cy.get('my-selector')
    .should('have.length',5)
    .eq(1)
    .should('contain', 'magic');
                </code></pre>
            </section>
            <section data-auto-animate>
                <h2>Chain of Commands - Retry Logic</h2>
                <pre data-id="code" class="javascript"><code data-line-numbers class="hljs"
                >cy.get('my-selector')
                </code></pre>
            </section>
            <section data-auto-animate>
                <h2>Chain of Commands - Retry Logic</h2>
                <pre data-id="code" class="javascript">
                    <code data-line-numbers="2" class="hljs"
                    >cy.get('my-selector')
    .should('have.length',5)    // FAIL
                    </code></pre>
            </section>
            <section data-auto-animate>
                <h2>Chain of Commands - Retry Logic</h2>
                <pre data-id="code" class="javascript"><code data-line-numbers class="hljs"
                >cy.get('my-selector')
                </code></pre>
            </section>
            <section data-auto-animate>
                <h2>Chain of Commands - Retry Logic</h2>
                <pre data-id="code" class="javascript">
                    <code data-line-numbers="2" class="hljs"
                    >cy.get('my-selector')
    .should('have.length',5)
                    </code></pre>
            </section>
            <section data-auto-animate>
                <h2>Chain of Commands - Retry Logic</h2>
                <pre data-id="code" class="javascript"><code data-line-numbers="3" class="hljs"
                >cy.get('my-selector')
    .should('have.length',5)
    .eq(1)
                </code></pre>
            </section>
            <section data-auto-animate>
                <h2>Chain of Commands - Retry Logic</h2>
                <pre data-id="code" class="javascript"><code data-line-numbers="4" class="hljs"
                >cy.get('my-selector')
    .should('have.length',5)
    .eq(1)
    .should('contain', 'magic');
                </code></pre>
            </section>
            <section data-auto-animate>
                <h2>Chain of Commands - Retry Logic</h2>
                <pre data-id="code" class="javascript"><code data-line-numbers="4" class="hljs"
                >cy.get('my-selector')
    .should('have.length',5)
    .eq(1)
    .should('contain', 'magic'); // FAIL
                </code></pre>
            </section>
            <section data-auto-animate>
                <h2>Chain of Commands - Retry Logic</h2>
                <pre data-id="code" class="javascript"><code data-line-numbers class="hljs"
                >cy.get('my-selector')
                </code></pre>
            </section>
            <section data-auto-animate>
                <h2>Chain of Commands - Retry Logic</h2>
                <pre data-id="code" class="javascript"><code data-line-numbers="2" class="hljs"
                >cy.get('my-selector')
    .should('have.length',5)
                </code></pre>
            </section>
            <section data-auto-animate>
                <h2>Chain of Commands - Retry Logic</h2>
                <pre data-id="code" class="javascript"><code data-line-numbers="3" class="hljs"
                >cy.get('my-selector')
    .should('have.length',5)
    ...
                </code></pre>
            </section>
        </section>

        <section>
            <h1>Übung 4: Screenshot & Video</h1>
        </section>

        <section>
            <section>
                <h1>cy.request vs cy.intercept</h1>
            </section>
            <section>
                <h2>cy.request – Direkt API testen</h2>
                <p><strong>Zweck:</strong> HTTP-Anfragen direkt senden und prüfen.</p>
                <p><strong>Einsatzgebiet:</strong></p>
                <ul>
                    <li>Backend-APIs testen</li>
                    <li>Testdaten vorbereiten (z. B. Benutzer erstellen)</li>
                    <li>Systemzustände prüfen</li>
                </ul>
            </section>
            <section>
                <h2>cy.request – Beispiel</h2>
                <pre data-id="code" class="javascript"><code data-line-numbers="1,2|3,6|4,5" class="hljs"
                >cy.request('POST', '/api/login',
                    { username: 'test', password: 'test123' })
  .then((response) => {
    expect(response.status).to.eq(200);
    expect(response.body).to.have.property('token');
  });
                </code></pre>
            </section>
            <section>
                <h2>cy.intercept – Netzwerkanfragen steuern</h2>
                <p><strong>Zweck:</strong></p>
                <ul>
                    <li>Anfragen abfangen und Stub- oder Mock-Daten verwenden</li>
                    <li>Netzwerkverkehr überwachen</li>
                </ul>
                <p><strong>Einsatzgebiet:</strong></p>
                <ul>
                    <li>API-Fehler simulieren</li>
                    <li>Tests isolieren (kein echter Backend-Aufruf)</li>
                    <li>Frontend-Integration testen</li>
                </ul>
            </section>
            <section>
                <h2>cy.intercept – Beispiel</h2>
                <pre data-id="code" class="javascript"><code data-line-numbers="1,2|4|5,7|6" class="hljs"
                >cy.intercept('GET', '/api/data', { fixture: 'data.json' })
                    .as('getData');

cy.visit('/dashboard');
cy.wait('@getData').then((interception) => {
  expect(interception.response.statusCode).to.eq(200);
});
                </code></pre>
                <pre>

    </pre>
            </section>
            <section class="small-text">
                <h2>cy.request vs cy.intercept</h2>
                <table>
                    <tr>
                        <th>Merkmal</th>
                        <th>cy.request</th>
                        <th>cy.intercept</th>
                    </tr>
                    <tr>
                        <td>Zweck</td>
                        <td>Direkte HTTP-Anfragen senden</td>
                        <td>Anfragen abfangen und manipulieren</td>
                    </tr>
                    <tr>
                        <td>Browser-Interaktion</td>
                        <td>Nicht erforderlich</td>
                        <td>Browser-basiert</td>
                    </tr>
                    <tr>
                        <td>Mocking möglich?</td>
                        <td>Nein</td>
                        <td>Ja</td>
                    </tr>
                    <tr>
                        <td>Anwendungsbereich</td>
                        <td>API-Tests, Datenvorbereitung</td>
                        <td>Überwachen, Stubben, Mocking von Requests</td>
                    </tr>
                </table>
            </section>
        </section>

        <section>
            <section>
                <h2>Best Practices</h2>
            </section>
            <section>
                <h2>Resiliente Tests</h2>
                <p>Verwende stabile Selectoren (z.B. `data-cy`), um auf UI-Elemente zuzugreifen.</p>
            </section>
            <section>
                <h2>Schreibe unabhängige Tests</h2>
                <p>Tests sollten isoliert und unabhängig voneinander sein.</p>
            </section>
            <section>
                <h2>DRY - Don't repeat yourself (too often)</h2>
                <p>Verwende Custom Commands - Erstelle wiederverwendbare Befehle für häufige Aktionen, um den Testcode
                    zu vereinfachen</p>
            </section>
            <section>
                <h1>Aber</h1>
                <h2>KISS - Keep It Simple Stupid</h2>
                <p>Nicht alles muss in ein Command - Halte die Tests so einfach wie möglich, um die Wartbarkeit zu
                    erhöhen.</p>
            </section>
            <section>
                <h2>Nutze `cy.fixture()` für Testdaten</h2>
                <p>Lade Testdaten aus externen Dateien, um die Tests sauber und wartbar zu halten.</p>
            </section>
            <section>
                <h2>Nutze `cy.intercept()` für API-Stubbing</h2>
                <p>Simuliere API-Antworten, um Tests schneller und zuverlässiger zu machen.</p>
            </section>
            <section>
                <h2>Setze den Zustand vor jedem Test zurück</h2>
                <p> ..., um Seiteneffekte zu vermeiden (`beforeEach`).</p>
            </section>
            <section>
                <h2>Verwende `cy.wait()` nur, wenn es WIRKLICH nötig ist</h2>
            </section>
            <section>
                <h2>Halte deine Testdaten realistisch und aktuell.</h2>
            </section>
        </section>
    </div>

    <img src="images/adesso-logo.png" class="adesso-logo" alt="adesso Logo">
</div>

<script src="node_modules/reveal.js/dist/reveal.js"></script>
<script src="node_modules/reveal.js/plugin/notes/notes.js"></script>
<script src="node_modules/reveal.js/plugin/highlight/highlight.js"></script>
<script>
    Reveal.initialize({
        slideNumber: true,
        autoPlayMedia: true,
        plugins: [RevealNotes, RevealHighlight],
    });
</script>
</body>
</html>